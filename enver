#!/bin/bash
#
# enver 2.2.0
#
# Liefert die Uebersetzung eines englische Verbs aus einer Woerterbuchdatei von "dict.cc".
#
# Fuer eine Bedienungsanleitung "source enver --help" aufrufen!
#
# Stand: 2018-03-17
# Autor: Bernd Storck
#
# Veroeffentlicht via "https://www.facebook.com/BStLinux/"
#

script_name="enver"
script_version="2.2.0"
vocabulary="dictverbs.txt"
Tab="	"

function default_output() {
	local searched="$1"
	grep -E "^[[:blank:]]*(to )\<$searched\>$Tab" "$vocabulary" | tr "\t" "#" | column -s"#" -t
	return "$(grep -c -E "^[[:blank:]]*(to )\<$searched\>$Tab" "$vocabulary")"

}

function print_all_verbs() {
	local searched="$1"
	local counter
	grep -E "^[[:blank:]]*(to )\<$searched\>.*$Tab" "$vocabulary" | tr "\t" "#" | column -s"#" -t > /tmp/enver.tmp
	if test -s /tmp/enver.tmp; then
		counter="$(wc -l '/tmp/enver.tmp' | cut -d" " -f1)" 
		if [[ "$counter" -gt 24 ]]; then
			if [ "$(which less)" ]; then
				less -S /tmp/enver.tmp
			elif [ "$(which most)" ]; then
				most /tmp/enver.tmp
			else
				more /tmp/enver.tmp
			fi
		else
			cat /tmp/enver.tmp
		fi
	else
		counter=0
		echo "Kein Datensatz, keine Erklärung zu \"$searched\" gefunden." > /dev/stderr
	fi
	rm -f /tmp/enver.tmp
	return $counter
}

function print_verbs_full() {
	# Finds the searched string if it is in the english field even if it's only
	# a part of a word. 
	#
	# In opposite to the function "print_full", this function looks only for lines,
	# which are beginning with "to " followed by a word containing the search string.
	local searched="$1"
        grep "^[^#]" "$vocabulary" | grep -iE "^to +([[:alpha:]]-?)*$1" | grep -F --color=always "$1"
	return $?
}

function print_full() {
	# Finds the searched string if it is in the english field even if it's only
	# a part of a word. But it ignores the occurence of the string in the annotations
	# or tags at the end of the english field. Those annotations are written between
	# squared brackets "[anntotation or tag]".

	local searched="$1"
        grep "^[^#]" "$vocabulary" | grep -iE "^[^[$Tab]*$1" | grep -F --color=always "$1"
	return $?
}	

function print_all() {
	# Fields are separated by tabs.  First field is English, second German. 
	# Finds all records/lines with the searched string in the first field, even
	# if it is a part of a word or part of an annotation beween squared brackets.  
	#
	# The second search string contains three tab characters between the pair of 
	# quotation marks!
	local searched="$1"
	grep "^[^#]" "$vocabulary" | grep --color=always -iE "^[^$Tab]*$1[^$Tab]*$Tab"
	return "$?"
}

function deep_search_cascade() {
	# This extended search tries to find datasets by a cascade of three regular expressions, the
	# cascade will be stopped if one regular expression has found matching datasets.

	local searched="$1"
	echo "Weitergehende Suche auch nach Wortteilen startet." > /dev/stderr
	sleep .75
	print_verbs_full "$1"
	if [ "$?" -ne 0 ]; then
		print_full "$1"
		if [ "$?" -ne 0 ]; then
			echo "Weitergehende Suche ohne Ergebnis." > /dev/stderr
			echo
			sleep .5
			echo "Suche nach jedem Vorkommen des Such-Strings startet." > /dev/stderr
			print_all "$1"
			if [ "$?" -ne 0 ]; then
				echo "Die Zeichenkette \"$1\" kommt im englischen Teil der Datenbasis nicht vor." > /dev/stderr
			fi
		fi
	fi
}

function phrases() {
	local searched="$1"
	grep -e "^[[:blank:]]*[A-Z]" -e "\[Redewendung\]" -e "\[idiom\]" "$vocabulary" | \
	sed "s/\[Redewendung\]//" | grep -iE "^[[:blank:]]*[^	]*\<$searched\>.*	" | \
	grep --color=always -wi "$searched" | tr "\t" "#" | column -s"#" -t
}

function write_amount_of_phrases() {

	local searched="$1"
	local amount_of_phrases
	amount_of_phrases=$(grep -e "^[[:blank:]]*[A-Z]" -e "\[Redewendung\]" -e "\[idiom\]" "$vocabulary" | \
	grep -c -iE "^[[:blank:]]*[^	]*\<$searched\>.*	")

	if [ "$amount_of_phrases" -gt 0 ]; then

		if [ "$amount_of_phrases" -gt 1 ]; then
			local object_name="Datensätze"
		else
			local object_name="Datensatz"
		fi
		echo "\"$script_name -P $searched\" liefert $amount_of_phrases $object_name." > /dev/stderr
	
	fi
}

function write_total_amount() {
	# Counts how many datasets the command "enver -V" finds.

	local searched="$1"
	local amount
	amount=$(grep -c -E "^[[:blank:]]*(to )\<$searched\>.*	" "$vocabulary")

	if [ "$amount" -gt 0 ]; then

		if [ "$amount" -gt 1 ]; then
			local object_name="Datensätze"
		else
			local object_name="Datensatz"
		fi
		echo -e  "\n\"$script_name -V $searched\" liefert $amount $object_name." > /dev/stderr
	
	fi
}

function count_cascade() {
	# Counts how many datasets will be found if calling the function "deep_search_cascade" for extended search.
	#
	# Extended search tries to find datasets by a cascade of three regular expressions, the
	# cascade will be stopped if one regular expression has found matching datasets.

	local searched="$1"
	local amount
        amount=$(grep "^[^#]" "$vocabulary" | grep -ciE "^to +([[:alpha:]]-?)*$1") # Counts print_verbs_full().
	if [ "$amount" -eq 0 ]; then
        	amount=$(grep "^[^#]" "$vocabulary" | grep -ciE "^[^[$Tab]*$1") # Counts print_full().
		if [ "$amount" -eq 0 ]; then  # Count print_all():
			amount=$(grep "^[^#]" "$vocabulary" | grep --color=always -ciE "^[^$Tab]*$1[^$Tab]*$Tab")
		fi
	fi
	if [ "$amount" -gt 1 ]; then 
		echo -e "\nDie vertiefte Suche mit \"$script_name -e $searched\" findet $amount Datensätze."
	elif [ "$amount" -eq 1 ]; then
		echo -e "\nDie vertiefte Suche mit \"$script_name -e $searched\" findet einen Datensatz."
	else
		echo "Die Wörterbuchdatei enthält keinen Datensatz mit der Zeichenkette \"$searched\" in Englisch."
	fi
	return "$amount"
}

display_help_screen() {
 	echo "$script_name $script_version"
	echo -e "\t\"$script_name\" zeigt Übersetzungen englischer Verben ins Deutsche an."
	echo -e "\nAUFRUFFORMAT:"
	echo -e "\t$script_name [-v|-V|-e|-D|-P|-p|-f|-a|-h] VOKABEL"
	echo -e "\nBEISPIELE:"
	echo -e "\t$script_name -v translate"
	echo -e "\t$script_name translate"
	echo -e "\n\t(Beiden Aufrufe bewirken das selbe. \"translate\" ist hier das Wort, nach dem gefragt wird.)"
	echo -e "\nAUFRUFPARAMETER:";
	echo -e "\t-v\tGibt schnell eine kurze Auskunft über ein englisches Verb."
	echo -e "\t-e\tKann für eine erweiterte Suche verwendet werden, nachdem \"$script_name -v\" erfolglos war."
	echo -e "\t-V\tSucht nur nach englischen Verben und listet alle dazu verfügbaren Datensätze auf."
	echo -e "\t-D\tSucht von einem deutschen Wort ausgehend nach englischen Verben."
	echo -e "\t-P\tFindet Redewendungen (engl. \"phrases\") und Sätze mit der Zeichenkette."
	echo -e "\t-p\tKombiniert \"-v\" (kurze Auskunft) mit \"-P\" (Liste von Redewendungen)."
	echo -e "\t-f\tZeigt Datensätze mit der gesuchten Zeichenkette im englischen Vokabeltext."
	echo -e "\t-a\tZeigt alle Datensätze mit der gesuchten Zeichenkette im englischen Datenfeld."
	echo -e "\t-h\tZeigt diese Hilfeseite an."
	echo -e "\nALTERNATIVE SPRECHENDE AUFRUFPARAMETER:";
	echo -e "\t-v \t--verb"
	echo -e "\t-e \t--weiter, --erweitere, --extend, --deep-search"
	echo -e "\t-V \t--verbs"
	echo -e "\t-D \t--deutsch, --de-en"
	echo -e "\t-P \t--phrases"
	echo -e "\t-p \t--phrases-too"
	echo -e "\t-f \t--full"
	echo -e "\t-a \t--all, --alle, --alles"
	echo -e "\t-h \t--help"
}


case $1 in

  -v|--verb)
	# "Short list, simple info about a verb:
	default_output "$2"
	if [ $? -ne 0 ]; then
		write_total_amount "$2"
		write_amount_of_phrases "$2"
	else  # if "enver -v" does not succeed, automatically execute the basic function of "enver -V":
		print_all_verbs "$2" # print_all_verbs returns the number of found datasets. 0 means no success.
		if [ "$?" -eq 0 ]; then  
			count_cascade "$2"
		fi
	fi
	;;

  -V|--verbs)
	# Long list about the searched verb:
	print_all_verbs "$2"
	if [ "$?" -eq 0 ]; then
		sleep 1
		echo
		echo "Weitergehende Suche auch nach Wortteilen startet." > /dev/stderr
		sleep .75
		print_verbs_full "$2"
		if [ "$?" -ne 0 ]; then
			print_full "$2"
			if [ "$?" -ne 0 ]; then
				echo "Weitergehende Suche ohne Ergebnis." > /dev/stderr
				echo
				sleep .5
				echo "Suche nach jedem Vorkommen des Such-Strings startet." > /dev/stderr
				print_all "$2"
				if [ "$?" -ne 0 ]; then
					echo "Die gesuchte Zeichenkette kommt im englischen Teil der Datenbasis nicht vor." > /dev/stderr
				fi
			fi
		fi
	fi
	;;

  -e|-E|--weiter|--erweitere|--extend|--deep-search|--deep_search|--deep)
	# Start der Suchkaskade, die stufenweise bis drei verschiedene reguläre Ausdrücke benutzt, 
    	# um irgendwelche passenden Datensätze zur gesuchten Zeichenkette zu finden.
	deep_search_cascade "$2"
	;;

  -g|-d|-G|-D|--de-en|--german|--deutsch)
	# Find a verb to a german word:
	grep -E "^[[:blank:]]*(to ).*$Tab.*\<$2\>" "$vocabulary" | tr "\t" "#" | column -s"#" -t
	;;

  -p|--phrases-too|--phrases_too|-Pv|-vP)
	# Find also phrases, combines "-v" with "-P":
	default_output "$2"
	echo
	phrases "$2"
	write_total_amount "$2"
	;;

  -P|--phrases)
	# Find and write only phrases:
	phrases "$2"
	;;

  -pvf|--verbs-full)
	# Only for testing purposes, call not mentioned in help documentation.
	# Finds a string even if it is a part of a word, but only in words directly following "^to ".
	print_verbs_full "$2"
	;;

  -f|--full)
	# Finds a string even if it is a part of a word.  
	print_full "$2"
	;;

  -a|--all|--alle|--alles)
	# Finds all records/lines with the searched string in English.
	print_all "$2"
	;;

  -h|--help)
	display_help_screen
	;;

  *)
	# Short list, simple info about a verb, same action as with "-v":
	default_output "$1"
	if [ $? -ne 0 ]; then
		write_total_amount "$1"
		write_amount_of_phrases "$1"
	else  # if "enver -v" does not succeed, automatically execute the basic function of "enver -V":
		print_all_verbs "$1" # print_all_verbs returns the number of found datasets. 0 means no success.
		if [ "$?" -eq 0 ]; then  
			count_cascade "$1"
		fi
	fi
	;;

esac


