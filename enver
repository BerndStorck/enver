#! /bin/bash 
#
#  enver 3.4.2
#
#  Liefert die Uebersetzung eines englische Verbs aus einer Woerterbuchdatei von "dict.cc".
#
#  Fuer eine Bedienungsanleitung "source enver --help" aufrufen!
#
#  Stand: 2018-06-22
#  Autor: Bernd Storck
#
# Veroeffentlicht via "https://www.facebook.com/BStLinux/"
#


# TECHNICAL COMMENT FOR PROGRAMMERS
#
# enver (for "english verbs") filters a flat file database, which is a list of englisch verbs and
# their german meaning.
#
# Every data record is a line. Records are consisting of exactly two fields, which are separated 
# by a tab character. First field contains the englisch part, second field the german equivalent.
#
# The fields have a substructure, containing for example tags.


# Static Values:
script_name="enver"
script_version="3.4.2"
Tab="	"


# Default Values:
LINECOUNTER="none"


# Current Dynamic Values:
vocabulary="$(dirname "$(which enver)")/dictverbs.txt"
# vocabulary="$(dirname "$(which enver)")/cmcgnoosos-916510172-e6o859.txt"
nDATASETS=$(wc -l < "$vocabulary")

for i in tput stty
do
	if [ "$(which ${i})" ]; then
		LINECOUNTER="$i"
		break 
	fi
done


function get_terminal_height() {
	case "$LINECOUNTER" in
		tput)
			TERMINAL_HEIGHT=$(tput lines)
			;;
		stty)
			TERMINAL_HEIGHT=$(stty size | cut -d" " -f1)
			;;
		*)
			TERMINAL_HEIGHT=$(( nDATASETS +1 )) 	# Supresses every call of a pager, cause the 
								# value is greater than the amount of data sets.
			;;
	esac
}


function display_page_by_page() {

	local INPUTFILE
	local CMD

	tail -f "$INPUTFILE" > /dev/pts/4
	
	CMD="cat"  # default value

	# Current Values:
	INPUTFILE="$1"
	AMOUNT_OF_LINES="$(wc -l < "$1")" 
	get_terminal_height   # sets the value of the script global var TERMINAL_HEIGHT.

	if [[ "$AMOUNT_OF_LINES" -gt $(( TERMINAL_HEIGHT - 1 )) ]]; then
		# Defines the pager program to use: 
		for i in less most more pg
		do
			if [ "$(which ${i})" ]; then
				case "$i" in
				  less)
					CMD="less -SX"
					;;
				  *)
					CMD="${i}"
					;;
				esac
				break 
			fi
		done
	fi

	eval "${CMD} $INPUTFILE"  # Calls pager or cat for displaying the file with the resulting data sets.
}


function define_numerus() {

		if [ "$1" -gt 1 ]; then
			OBJECT_NAME="$3"
		else
			OBJECT_NAME="$2"
		fi
}		


function default_output() {
	local searched="$1"
	grep -E "^[[:blank:]]*(to )\<$searched\>$Tab" "$vocabulary" | tr "\t" "#" | column -s"#" -t
	return "$(grep -c -E "^[[:blank:]]*(to )\<$searched\>$Tab" "$vocabulary")"

}

function print_all_verbs() {
	local searched="$1"
	local counter

	get_terminal_height

	grep -E "^[[:blank:]]*(to )\<$searched\>.*$Tab" "$vocabulary" | tr "\t" "#" | column -s"#" -t > /tmp/enver.tmp
	if test -s /tmp/enver.tmp; then
		display_page_by_page "/tmp/enver.tmp"
		counter=$AMOUNT_OF_LINES
	else
		counter=0
		echo "Kein Datensatz, keine Erklärung zu \"$searched\" gefunden." > /dev/stderr
	fi
	rm -f /tmp/enver.tmp
	return $counter
}

function print_verbs_full() {
	# Finds the searched string if it is in the english field even if it's only
	# a part of a word. 
	#
	# In opposite to the function "print_full", this function looks only for lines,
	# which are beginning with "to " followed by a word containing the search string.
	local searched="$1"
        grep -iE "^to +([[:alpha:]]-?)*$1" "$vocabulary"| grep -F --color=always "$1"
	return $?
}

function print_full() {
	# Finds the searched string if it is in the english field even if it's only
	# a part of a word. But it ignores the occurence of the string in the annotations
	# or tags at the end of the english field. Those annotations are written between
	# squared brackets "[anntotation or tag]".

	local searched="$1"
	grep -iE "^[^[$Tab]*$1" "$vocabulary" | grep -F --color=always "$1"
	return $?
}	

function print_all() {
	# Fields are separated by tabs.  First field is English, second German. 
	# Finds all records/lines with the searched string in the first field, even
	# if it is a part of a word or part of an annotation beween squared brackets.  
	#
	# The second search string contains three tab characters between the pair of 
	# quotation marks!
	local searched="$1"
	grep --color=always -iE "^[^$Tab]*$1[^$Tab]*$Tab" "$vocabulary"
	return "$?"
}


function approximate_search() {
	# agrep has limitations for the lenght of complex search patterns. Therefore is the 2. search level
	# a simplification of the search which is perforemd by level 1.
	#
	# Search level 4 finally tries to handle agreps problem with long search patterns by shortening the
	# searched word. This method was very successful in many test with some long words.

	local SEARCHED="$1"
	local SEARCH_LEVEL
	local MATCH_FOUND=1   # flag for "no match".
	local LEN
	local MAX

	echo -e "\nVersuch einer fehlertoleranten Suche startet." > /dev/stderr
	if [ $(which agrep) ]; then

		for SEARCH_LEVEL in 1 2 3 4;
		do

			case "$SEARCH_LEVEL" in
				1)
					agrep -1 "^[^$Tab]*$SEARCHED[^$Tab]*$Tab" "$vocabulary" | \
					agrep -1 -w "$SEARCHED" > /tmp/enver1.tmp
					MATCH_FOUND="$?"
					;;
				2)
					agrep -1 "$SEARCHED[^$Tab]*$Tab" "$vocabulary"          | \
					agrep -1 -w "$SEARCHED" > /tmp/enver1.tmp
					MATCH_FOUND="$?"
					;;
				3)
					agrep -1 "$SEARCHED[^$Tab]*$Tab" "$vocabulary" > /tmp/enver1.tmp
					MATCH_FOUND="$?"
					;;
				4)
					LEN=${#SEARCHED}
					MAX=$(bc <<< "scale=0; $LEN / 2")
					# echo "\"$SEARCHED\" ist $LEN Zeichen lang."
					# echo "MAX = $MAX"
					for i in $(seq 1 $MAX);
					do
						LEN=$(( LEN - 1 ))
						SEARCHED="${SEARCHED:0:$LEN}"
						agrep -2 "^[^$Tab]*$SEARCHED[^$Tab]*$Tab" "$vocabulary" > /tmp/enver1.tmp
						if [ "$?" -eq 0 ]; then
							# SUBLEVEL=".$i"
							MATCH_FOUND=0
							break
						fi
					done
					if [ $MATCH_FOUND -eq 1 ]; then 
						echo "Auch die fehlertolerante Suche hat kein ähnliches Wort gefunden."> /dev/stderr
						exit 1
					fi
					;;
			esac

			if [ $MATCH_FOUND -eq 0 ]; then
				cat /tmp/enver1.tmp | tr "\t" "#" | column -s"#" -t > /tmp/enver.tmp
				if [ "$?" -eq 0 ]; then
						rm /tmp/enver1.tmp
				else
						mv /tmp/enver1.tmp /tmp/enver.tmp
				fi
				# echo "approximate search level ${SEARCH_LEVEL}${SUBLEVEL}" > /dev/pts/0
				echo 
				display_page_by_page "/tmp/enver.tmp"
				exit 0
			fi
		done

	else
		echo "FEHLER: Das Programm \"agrep\" wurde nicht gefunden."
		echo -e "\nFür eine ungefähre, fehlertolerante Suche muss agrep vorhanden sein."
		echo "agrep bekommen Sie, wenn Sie das Paket \"glimpse\" installieren."
	fi
}		


function deep_search_cascade() {
	# This extended search tries to find datasets by a cascade of three regular expressions, the
	# cascade will be stopped if one regular expression has found matching datasets.

	local searched="$1"
	echo "Weitergehende Suche auch nach Wortteilen startet." > /dev/stderr
	# sleep .75
	print_verbs_full "$1"
	if [ "$?" -ne 0 ]; then
		print_full "$1"
		if [ "$?" -ne 0 ]; then
			echo "Weitergehende Suche ohne Ergebnis." > /dev/stderr
			echo
			# sleep .5
			echo "Suche nach jedem Vorkommen des Such-Strings startet." > /dev/stderr
			print_all "$1"
			if [ "$?" -ne 0 ]; then
				echo "Die Zeichenkette \"$1\" kommt im englischen Teil der Datenbasis nicht vor." > /dev/stderr
				approximate_search "$1"
			fi
		fi
	fi
}

function phrases() {
	# As phrases are identified lines which are beginning with an upper case letter or
	# containing "[Redewendung]" or containing "[idiom]".
	#
	# The searched string has to be in the first field, which ist the english part.
	local searched="$1"
	grep -e "^[[:blank:]]*[A-Z]" -e "\[Redewendung\]" -e "\[idiom\]" "$vocabulary" | \
	sed "s/\[Redewendung\]//" | grep -iE "^[[:blank:]]*[^	]*\<$searched\>.*	" | \
	grep --color=always -wi "$searched" | tr "\t" "#" | column -s"#" -t
}


function get_amount_of_approximate_matches() {

		local SEARCHED="$1"
		local AMOUNT

		if [ $(which agrep) ]; then
			AMOUNT=$(agrep -c1 "^[^$Tab]*$SEARCHED[^$Tab]*$Tab" "$vocabulary")
			if [ "$AMOUNT" -gt 0 ]; then

				define_numerus $AMOUNT "Datensatz" "Datensätze"
				echo -e "\n\"$script_name -c $SEARCHED\" liefert $AMOUNT $OBJECT_NAME. (Suche nach ungefähr übereinstimmenden Wörtern)" > /dev/stderr

			fi
		fi
}


function write_amount_of_phrases() {

	local SEARCHED="$1"
	local AMOUNT_OF_PHRASES
	AMOUNT_OF_PHRASES=$(grep -e "^[[:blank:]]*[A-Z]" -e "\[Redewendung\]" -e "\[idiom\]" "$vocabulary" | \
	grep -c -iE "^[[:blank:]]*[^	]*\<$SEARCHED\>.*	")

	if [ "$AMOUNT_OF_PHRASES" -gt 0 ]; then

		define_numerus $AMOUNT_OF_PHRASES "Redewendung" "Redewendungen"
		echo "\"$script_name -P $SEARCHED\" findet $AMOUNT_OF_PHRASES $OBJECT_NAME." > /dev/stderr
	
	fi
}

function write_total_amount() {
	# Counts how many datasets the command "enver -V" finds.

	local SEARCHED="$1"
	local AMOUNT
	AMOUNT=$(grep -c -E "^[[:blank:]]*(to )\<$SEARCHED\>.*	" "$vocabulary")

	if [ "$AMOUNT" -gt 0 ]; then

		define_numerus $AMOUNT "Datensatz" "Datensätze"
		echo -e  "\n\"$script_name -V $SEARCHED\" liefert $AMOUNT $OBJECT_NAME." > /dev/stderr
	
	fi
}

function count_cascade() {
	# Counts how many datasets the function "deep_search_cascade" for extended search finds.
	#
	# Extended search tries to find datasets by a cascade of three regular expressions, the
	# cascade will be stopped if one regular expression has found matching datasets.

	local searched="$1"
	local amount
	amount=$(grep -ciE "^to +([[:alpha:]]-?)*$1" "$vocabulary") # Counts print_verbs_full().
	if [ "$amount" -eq 0 ]; then
        	amount=$(grep -ciE "^[^[$Tab]*$1" "$vocabulary") # Counts print_full().
		if [ "$amount" -eq 0 ]; then  # Count print_all():
			amount=$(grep --color=always -ciE "^[^$Tab]*$1[^$Tab]*$Tab" "$vocabulary")
		fi
	fi
	if [ "$amount" -gt 1 ]; then 
		echo -e "\nDie vertiefte Suche mit \"$script_name -e $searched\" findet $amount Datensätze."
	elif [ "$amount" -eq 1 ]; then
		echo -e "\nDie vertiefte Suche mit \"$script_name -e $searched\" findet einen Datensatz."
	else
		echo "Die Wörterbuchdatei enthält keinen Datensatz mit der Zeichenkette \"$searched\" in Englisch."
	fi
	return "$amount"
}

display_help_screen() {
 	echo "$script_name $script_version"
	echo -e "\t\"$script_name\" zeigt Übersetzungen englischer Verben ins Deutsche an."
	echo -e "\nAUFRUFFORMAT:"
	echo -e "\t$script_name [-v|-e|-V|-c|-D|-P|-p|-f|-a|-h] VOKABEL"
	echo -e "\nBEISPIELE:"
	echo -e "\t$script_name -v translate"
	echo -e "\t$script_name translate"
	echo -e "\n\t(Beide Aufrufe bewirken das selbe. \"translate\" ist hier das Wort, nach dem gefragt wird.)"
	echo -e "\nAUFRUFPARAMETER:";
	echo -e "\t-v\tGibt schnell eine kurze Auskunft über ein englisches Verb."
	echo -e "\t-e\tKann für eine erweiterte Suche verwendet werden, nachdem \"$script_name -v\" erfolglos war."
	echo -e "\t-V\tSucht gründlich nach englischen Verben und listet alle dazu verfügbaren Datensätze auf."
	echo -e "\t-c\tSucht nach englischen Wörtern, die dem Suchwort ähneln."
	echo -e "\t-D\tSucht von einem deutschen Wort ausgehend nach englischen Verben."
	echo -e "\t-P\tFindet Redewendungen (engl. \"phrases\") und Sätze mit der Zeichenkette."
	echo -e "\t-p\tKombiniert \"-v\" (kurze Auskunft) mit \"-P\" (Liste von Redewendungen)."
	echo -e "\t-f\tZeigt Datensätze mit der gesuchten Zeichenkette im englischen Vokabeltext."
	echo -e "\t-a\tZeigt alle Datensätze mit der gesuchten Zeichenkette im englischen Datenfeld."
	echo -e "\t-h\tZeigt diese Hilfeseite an."
	echo -e "\nALTERNATIVE SPRECHENDE AUFRUFPARAMETER:";
	echo -e "\t-v \t--verb"
	echo -e "\t-e \t--weiter, --erweitere, --extend, --deep-search"
	echo -e "\t-V \t--verbs"
	echo -e "\t-c \t--circa, --etwa, --ungefähr, --proximate"
	echo -e "\t-D \t--deutsch, --de-en"
	echo -e "\t-P \t--phrases"
	echo -e "\t-p \t--phrases-too"
	echo -e "\t-f \t--full"
	echo -e "\t-a \t--all, --alle, --alles"
	echo -e "\t-h \t--help"
}


case $1 in

  -v|--verb)
	# "Short list, simple info about a verb:
	default_output "$2"
	if [ $? -ne 0 ]; then
		write_total_amount "$2"
		write_amount_of_phrases "$2"
	else  # if "enver -v" does not succeed, automatically execute the basic function of "enver -V":
		print_all_verbs "$2" # print_all_verbs returns the number of found datasets. 0 means no success.
		if [ "$?" -eq 0 ]; then  
			count_cascade "$2"
		fi
	fi
	;;

  -V|--verbs)
	# Long list about the searched verb:
	print_all_verbs "$2"
	if [ "$?" -eq 0 ]; then
		# sleep 1
		echo -e "\nWeitergehende Suche auch nach Wortteilen startet." > /dev/stderr
		# sleep .75
		print_verbs_full "$2"
		if [ "$?" -ne 0 ]; then
			print_full "$2"
			if [ "$?" -ne 0 ]; then
				echo "Weitergehende Suche ohne Ergebnis." > /dev/stderr
				# sleep .5
				echo -e "\nSuche nach jedem Vorkommen des Such-Strings startet." > /dev/stderr
				print_all "$2"
				if [ "$?" -ne 0 ]; then
					echo "Die gesuchte Zeichenkette kommt im englischen Teil der Datenbasis nicht vor." > /dev/stderr
					get_amount_of_approximate_matches "$2"
				fi
			fi
		fi
	fi
	;;

  -e|-E|--weiter|--erweitere|--extend|--deep-search|--deep_search|--deep)
		# Start der Suchkaskade, die stufenweise bis drei verschiedene reguläre Ausdrücke benutzt, 
		# um irgendwelche passenden Datensätze zur gesuchten Zeichenkette zu finden.
	deep_search_cascade "$2"
	;;

  -c|-C|--circa|--etwa|--ungefähr|--proximate)
	approximate_search "$2"
	;;

  -g|-d|-G|-D|--de-en|--german|--deutsch)
	# Find a verb to a german word:
	grep -E "^[[:blank:]]*(to ).*$Tab.*\<$2\>" "$vocabulary" | tr "\t" "#" | column -s"#" -t
	;;

  -p|--phrases-too|--phrases_too|-Pv|-vP)
	# Find also phrases, combines "-v" with "-P":
	default_output "$2"
	echo
	phrases "$2"
	write_total_amount "$2"
	;;

  -P|--phrases)
	# Find and write only phrases:
	phrases "$2"
	;;

  -pvf|--verbs-full)
	# Only for testing purposes, call not mentioned in help documentation.
	# Finds a string even if it is a part of a word, but only in words directly following "^to ".
	print_verbs_full "$2"
	;;

  -f|--full)
	# Finds a string even if it is a part of a word.  
	print_full "$2"
	;;

  -a|--all|--alle|--alles)
	# Finds all records/lines with the searched string in English.
	print_all "$2"
	;;

  -h|--help)
	display_help_screen
	;;

  *)
	# Short list, simple info about a verb, same action as with "-v":
	default_output "$1"
	if [ $? -ne 0 ]; then
		write_total_amount "$1"
		write_amount_of_phrases "$1"
	else  # if "enver -v" does not succeed, automatically execute the basic function of "enver -V":
		print_all_verbs "$1" # print_all_verbs returns the number of found datasets. 0 means no success.
		if [ "$?" -eq 0 ]; then  
			count_cascade "$1"
		fi
	fi
	;;

esac

exit 0

